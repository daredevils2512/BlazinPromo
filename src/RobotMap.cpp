// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"

//access pointer objects declared in RobotMap.h file
std::shared_ptr<CANTalon> RobotMap::drivetrainFrontLeftMotor;
std::shared_ptr<CANTalon> RobotMap::drivetrainRearLeftMotor;
std::shared_ptr<CANTalon> RobotMap::drivetrainFrontRightMotor;
std::shared_ptr<CANTalon> RobotMap::drivetrainRearRightMotor;
std::shared_ptr<frc::RobotDrive> RobotMap::drivetrainchassis;
std::shared_ptr<frc::Encoder> RobotMap::drivetrainLeftEncoder;
std::shared_ptr<frc::Encoder> RobotMap::drivetrainRightEncoder;
std::shared_ptr<frc::DoubleSolenoid> RobotMap::drivetrainShift;
std::shared_ptr<frc::DoubleSolenoid> RobotMap::shooterSolenoidOne;
std::shared_ptr<frc::DoubleSolenoid> RobotMap::shooterSolenoidTwo;
std::shared_ptr<frc::Relay> RobotMap::shooterSpike;
std::shared_ptr<frc::DoubleSolenoid> RobotMap::shooterFrisbeeSolenoid;
std::shared_ptr<CANTalon> RobotMap::shooterFrisbeeMotor;
std::shared_ptr<frc::DigitalInput> RobotMap::shooterFrisbeePhotoeye;

//runs on startup of the robot
void RobotMap::init() {
	//assign ports and settings to pointer objects declared in RobotMap.h
    frc::LiveWindow *lw = frc::LiveWindow::GetInstance();

    drivetrainFrontLeftMotor.reset(new CANTalon(4));
    lw->AddActuator("Drivetrain", "FrontLeftMotor", drivetrainFrontLeftMotor);
    
    drivetrainRearLeftMotor.reset(new CANTalon(6));
    lw->AddActuator("Drivetrain", "RearLeftMotor", drivetrainRearLeftMotor);
    
    drivetrainFrontRightMotor.reset(new CANTalon(0));
    lw->AddActuator("Drivetrain", "FrontRightMotor", drivetrainFrontRightMotor);
    
    drivetrainRearRightMotor.reset(new CANTalon(8));
    lw->AddActuator("Drivetrain", "RearRightMotor", drivetrainRearRightMotor);
    
    drivetrainchassis.reset(new frc::RobotDrive(drivetrainFrontLeftMotor, drivetrainRearLeftMotor,
              drivetrainFrontRightMotor, drivetrainRearRightMotor));
    
    drivetrainchassis->SetSafetyEnabled(false);
        drivetrainchassis->SetExpiration(0.5);
        drivetrainchassis->SetSensitivity(0.5);
        drivetrainchassis->SetMaxOutput(1.0);


    drivetrainLeftEncoder.reset(new frc::Encoder(0, 1, false, frc::Encoder::k4X));
    lw->AddSensor("Drivetrain", "LeftEncoder", drivetrainLeftEncoder);
    drivetrainLeftEncoder->SetDistancePerPulse(0.0153846154);
    drivetrainLeftEncoder->SetPIDSourceType(frc::PIDSourceType::kRate);
    drivetrainRightEncoder.reset(new frc::Encoder(2, 3, false, frc::Encoder::k4X));
    lw->AddSensor("Drivetrain", "RightEncoder", drivetrainRightEncoder);
    drivetrainRightEncoder->SetDistancePerPulse(0.0153846154);
    drivetrainRightEncoder->SetPIDSourceType(frc::PIDSourceType::kRate);

    drivetrainShift.reset(new frc::DoubleSolenoid(0,0,1));

    shooterSolenoidOne.reset(new frc::DoubleSolenoid(0,0,1));
    shooterSolenoidTwo.reset(new frc::DoubleSolenoid(0,0,1));
    shooterSpike.reset(new frc::Relay(0));

    shooterFrisbeeSolenoid.reset(new frc::DoubleSolenoid(0,0,1));
    shooterFrisbeeMotor.reset(new CANTalon(0));
    shooterFrisbeePhotoeye.reset (new DigitalInput(0));
}
